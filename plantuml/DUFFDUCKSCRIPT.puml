@startuml DUFFDUCK_FULL_SYSTEM
!theme plain
skinparam dpi 150
skinparam classAttributeIconSize 0
top to bottom direction
hide empty members
skinparam linetype ortho

abstract class Character {
    + CurrentHealth : int <<get>>
    + MaxHealth : int <<get>>
    + IsDead : bool <<get>>
    + <<virtual>> Initialize(maxHealth:int) : void
    + <<virtual>> TakeDamage(amount:int) : void
    + <<virtual>> Heal(amount:int) : void
    + {abstract} Die() : void
    + <<virtual>> Move(direction:Vector2) : void
    + {abstract} Attack() : void
}
MonoBehaviour <|-- Character
IDamageable <|-- Character

class Player {
    +  <<event>> OnCoinCollected : System.Action<int> 
    + GetChargePower() : float
    + PlayerName : string <<get>>
    + FaceDir : int <<get>> = 1
    + Initialize(data:PlayerData, cardManager:CardManager, careerSwitcher:CareerSwitcher) : void
    + <<override>> Move(direction:Vector2) : void
    + ApplySpeedModifier(multiplier:float, duration:float) : void
    + HandleInteract() : void
    + <<virtual>> Jump() : void
    + <<override>> TakeDamage(amount:int) : void
    + <<override>> Heal(amount:int) : void
    + Revive(reviveHP:int) : void
    + <<override>> Die() : void
    + GetCurrentCareerID() : DuckCareer
    + SetHealthBarUI(healthBarUI:HealthBarUI) : void
    + HookScoreUI(scoreUI:ScoreUI, initialCoin:int) : void
    + AddCoin(amount:int) : void
    + AddToken(amount:int) : void
    + GetCurrency() : Currency
    + <<override>> Attack() : void
    + <<virtual>> ChargeAttack(power:float) : void
    + <<virtual>> RangeAttack(target:Transform) : void
    + <<virtual>> ApplyDamage(target:IDamageable, amount:int) : void
    + <<virtual>> UseSkill() : void
    + <<virtual>> OnSkillCooldown() : void
    + UseCard(card:Card) : void
    + EnterOverdrive() : void
    + ExitOverdrive() : void
    + SetFXProfile(newProfile:CareerEffectProfile) : void
    + OnCareerChanged(newCareer:DuckCareerData) : void
    + IsDuckling : bool <<get>>
    + UpdatePlayerFormState() : void
    + ResetState() : void
}
Character <|-- Player
IDamageable <|-- Player
IAttackable <|-- Player
ISkillUser <|-- Player
Player --> "CurrentCareerData" DuckCareerData
Player --> "CurrentCareerID" DuckCareer
Player --> "CurrentMapType" MapType
Player --> "FXProfile" CareerEffectProfile
Player --> "CurrentCareerSkill" CareerSkillBase

class PlayerData {
    + PlayerName : string <<get>> <<set>>
    + SelectedCareer : string <<get>> <<set>>
    + MaxHealth : int <<get>> <<set>>
    + Speed : float <<get>> <<set>>
    + AttackPower : float <<get>> <<set>>
    + Defense : int <<get>> <<set>>
    + PlayerData(currency:Currency, progress:GameProgressData)
    + UpgradeStat(statName:string, value:int) : void
    + IsDefaultDuckling : bool <<get>> <<set>>
    + ResetPlayerState() : void
}
PlayerData --> "Currency" Currency
PlayerData --> "Progress" GameProgressData

class PlayerInteract {
    + HasItem() : bool
    + TryPickUp() : void
    + SetThrowable(itemObject:GameObject) : void
    + ThrowItem() : void
    + ConsumeHeldItem() : GameObject
}
MonoBehaviour <|-- PlayerInteract

class CareerSwitcher {
    +  <<event>> OnCareerChangedEvent : Action<DuckCareerData> 
    +  <<event>> OnRevertToDefaultEvent : Action 
    +  <<event>> OnResetCareerCycle : Action 
    + IsDuckling : bool <<get>>
    + SwitchCareer(newCareer:DuckCareerData) : void
    + GetAvailableCareers() : List<DuckCareer>
    + OnCareerChanged(newCareer:DuckCareerData) : void
    + ApplyCareerAppearance() : void
    + GetCurrentCareer() : DuckCareerData
    + RevertToDefault() : void
    + StartCareerTimer(duration:float) : void
    + CanChangeTo(newCareer:DuckCareerData) : bool
    + GetCareerData(type:DuckCareer) : DuckCareerData
    + GetCareerDataByName(name:string) : DuckCareerData
    + SwitchCareerByName(careerName:string) : void
}
class CareerBodyMap {
}
class "IReadOnlyList`1"<T> {
}
MonoBehaviour <|-- CareerSwitcher
ICareerSwitchable <|-- CareerSwitcher
CareerSwitcher --> "EffectProfile" CareerEffectProfile
CareerSwitcher --> "CareerBodyMaps<CareerBodyMap>" "IReadOnlyList`1"
CareerSwitcher --> "CurrentCareer" DuckCareerData
CareerSwitcher +-- CareerBodyMap
CareerBodyMap --> "careerID" DuckCareer
CareerBodyMap --> "bodyPrefab" GameObject
CareerBodyMap --> "fxProfile" CareerEffectProfile

class DuckCareerData {
    + CareerDuration : float <<get>>
    + CareerCooldownAfterUse : float <<get>>
    + BaseCooldown : float = 10f
    + DisplayName : string <<get>>
    + BaseHealth : int <<get>>
    + BaseSpeed : float <<get>>
    + SkillName : string <<get>>
    + SkillDescription : string <<get>>
    + ChefMonCoinMinBonusValue : int <<get>>
    + ChefMonCoinMaxBonusValue : int <<get>>
    + PeterMonAttackSkipChance : float <<get>>
    + PeterMonBuffDuration : float <<get>>
    + ProgrammerMonCoinBonusValue : int <<get>>
    + KahootMonDisableChance : float <<get>>
    + GetCareerStats() : string
    + ActivateSkill(player:Player) : void
}
ScriptableObject <|-- DuckCareerData
DuckCareerData --> "CareerSkill" CareerSkillBase
DuckCareerData --> "CareerID" DuckCareer
DuckCareerData --> "SkillIcon" Sprite
DuckCareerData --> "CardType" CardType
DuckCareerData --> "CareerIcon" Sprite
DuckCareerData --> "CareerCard" Sprite

enum DuckCareer {
    None= 0,
    Duckling= 1,
    Chef= 2,
    Dancer= 3,
    Detective= 4,
    Doctor= 5,
    Firefighter= 6,
    Motorcycle= 7,
    Programmer= 8,
    Singer= 9,
    Muscle= 10,
}

abstract class CareerSkillBase {
    + <<virtual>> Initialize(player:Player) : void
    + {abstract} UseCareerSkill(player:Player) : void
    + <<virtual>> PerformAttack(player:Player) : void
    + <<virtual>> PerformChargeAttack(player:Player) : void
    + <<virtual>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<virtual>> Cleanup(player:Player) : void
    + <<virtual>> OnEnterOverdrive(player:Player) : void
    + <<virtual>> OnExitOverdrive(player:Player) : void
    + <<virtual>> OnTakeDamage(player:Player, damage:int) : void
    + <<virtual>> OnBeforeDie(player:Player) : bool
}
ScriptableObject <|-- CareerSkillBase

class ChefSkill {
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- ChefSkill

class DancerSkill {
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- DancerSkill

class DetectiveSkill {
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- DetectiveSkill

class DoctorSkill {
    + <<override>> Initialize(player:Player) : void
    + <<override>> OnTakeDamage(player:Player, incomingDamage:int) : void
    + <<override>> OnBeforeDie(player:Player) : bool
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- DoctorSkill

class DucklingSkill {
    + <<override>> Initialize(player:Player) : void
    + <<override>> Cleanup(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> OnTakeDamage(player:Player, dmg:int) : void
    + <<override>> OnBeforeDie(player:Player) : bool
}
CareerSkillBase <|-- DucklingSkill

class FireFighterSkill {
    + <<override>> Initialize(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> PerformRangeAttack(player:Player, target:Transform) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- FireFighterSkill

class MotorcycleSkill {
    + HasJumpBuff : bool <<get>>
    + <<override>> Initialize(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> OnTakeDamage(player:Player, dmg:int) : void
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- MotorcycleSkill

class MuscleSkill {
    + <<override>> Initialize(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
    + <<override>> OnTakeDamage(player:Player, dmg:int) : void
    + <<override>> OnBeforeDie(player:Player) : bool
    + <<override>> Cleanup(player:Player) : void
}
CareerSkillBase <|-- MuscleSkill

class ProgrammerSkill {
    + <<override>> Initialize(player:Player) : void
    + <<override>> Cleanup(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
}
CareerSkillBase <|-- ProgrammerSkill

class SingerSkill {
    + <<override>> Initialize(player:Player) : void
    + IsMapBuffActive : bool <<get>>
    + <<override>> Cleanup(player:Player) : void
    + <<override>> UseCareerSkill(player:Player) : void
    + <<override>> PerformAttack(player:Player) : void
    + <<override>> PerformChargeAttack(player:Player) : void
}
CareerSkillBase <|-- SingerSkill

enum CardType {
    None= 0,
    Career= 1,
    Berserk= 2,
}

abstract class Enemy {
    + SpawnWeight : float = 30f
    + CanDetectOverride : bool = true
    + Speed : float <<get>> <<set>>
    + AttackPower : int <<get>> <<set>>
    + DetectionRange : float <<get>> <<set>>
    + InitializeFromData() : void
    + SetDependencies(player:Player, spawner:CollectibleSpawner, cardManager:CardManager, buffManager:BuffManager, pool:IObjectPool) : void
    + <<virtual>> Move() : void
    + <<override>> Attack() : void
    + <<virtual>> DetectPlayer(playerPos:Vector3) : bool
    + <<virtual>> DetectPlayer(playerPos:Vector3, customRange:float) : bool
    + <<virtual>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<virtual>> DisableBehavior(duration:float) : void
    + <<override>> TakeDamage(amount:int) : void
    + <<override>> Die() : void
    + <<virtual>> ChargeAttack(power:float) : void
    + <<virtual>> RangeAttack(target:Transform) : void
    + <<virtual>> ApplyDamage(target:IDamageable, amount:int) : void
    + Confuse(duration:float) : void
    + ApplyFear(duration:float) : void
}

enum EnemyType {
    None= 0,
    KahootMon= 1,
    GhostWorkMon= 2,
    LotteryMon= 3,
    DoggoMon= 4,
    RedlightMon= 5,
    PeterMon= 6,
    MamaMon= 7,
    MooPingMon= 8,
    GoldenMon= 9,
}
class EnemyTypeExtensions <<static>> {
    + {static} IsCommon(enemyType:EnemyType) : bool
    + {static} IsRare(enemyType:EnemyType) : bool
    + {static} GetAssociatedMaps(enemyType:EnemyType) : List<MapType>
    + {static} CanAppearInMap(enemyType:EnemyType, mapType:MapType) : bool
}
enum EnemyState {
    Idle,
    Chase,
    Attack,
    Confused,
    Disabled,
    Dead,
}

class DoggoMon {
    + <<override>> Move() : void
    + ChasePlayer(player:Player) : void
    + Stop() : void
    + SetDirection(direction:Vector2) : void
    + <<override>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<override>> Die() : void
}
Enemy <|-- DoggoMon

class GhostWorkMon {
    + TryTeleportAttack() : void
    + <<override>> Attack() : void
    + <<override>> Die() : void
}
Enemy <|-- GhostWorkMon

class GoldenMon {
    + <<override>> Move() : void
    + DanceAttack() : void
    + BreakPlatform() : void
    + DropGoldenCoins() : void
    + <<override>> Die() : void
}
Enemy <|-- GoldenMon

class KahootMon {
    + <<override>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<override>> Attack() : void
    + ShowQuestion() : void
    + FireBlock(color:Color) : void
    + ActivateEffect(player:Player) : void
    + DoubleSpeedMode() : void
    + <<override>> Die() : void
}
Enemy <|-- KahootMon

class LotteryMon {
    + <<override>> Attack() : void
    + ApplyGoodLuck(player:Player) : void
    + ApplyBadLuck(player:Player) : void
    + <<override>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<override>> Die() : void
}
Enemy <|-- LotteryMon

class MamaMon {
    + <<override>> Attack() : void
    + BoilSplash() : void
    + RecoverHP() : void
    + <<override>> Die() : void
}
Enemy <|-- MamaMon

class MooPingMon {
    + <<override>> Move() : void
    + ChasePlayer(player:Player) : void
    + Stop() : void
    + SetDirection(direction:Vector2) : void
    + <<override>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<override>> DisableBehavior(duration:float) : void
    + <<override>> Die() : void
}
Enemy <|-- MooPingMon

class RedlightMon {
    + <<override>> Attack() : void
    + SpawnCarAttack() : void
    + SwitchLightState() : void
    + WarnPlayer() : void
    + ForceSignalState(state:string, forcePermanent:bool) : void
    + <<override>> Die() : void
}
Enemy <|-- RedlightMon

class PeterMon {
    + <<override>> Move() : void
    + <<override>> ApplyCareerBuff(data:DuckCareerData) : void
    + <<override>> DisableBehavior(duration:float) : void
    + <<override>> Die() : void
}
Enemy <|-- PeterMon

Character <|-- Enemy
IAttackable <|-- Enemy
Enemy --> "EnemyType" EnemyType

class Projectile {
    + PoolTag : string <<get>>
    + SetDamage(amount:int) : void
}
MonoBehaviour <|-- Projectile

class Currency {
    + {static}  <<event>> OnCurrencyChanged : Action 
    + Coin : int <<get>> <<set>>
    + Token : int <<get>> <<set>>
    + KeyMap : int <<get>> <<set>>
    + Initialize(switcher:CareerSwitcher) : void
    + AddCoin(amount:int) : void
    + UseCoin(amount:int) : bool
    + AddToken(amount:int) : void
    + UseToken(amount:int) : bool
    + AddKey(amount:int) : void
    + UseKey(amount:int) : bool
    + ResetAll() : void
    + <<override>> ToString() : string
}

abstract class StoreBase {
    + {abstract} StoreName : string <<get>>
    + <<virtual>> Initialize(manager:StoreManager, injectedItems:List<StoreItem>) : void
    + <<virtual>> GetItem(id:string) : StoreItem
    + {abstract} Purchase(item:StoreItem) : bool
    + <<virtual>> IsUnlocked(item:StoreItem) : bool
}

class StoreExchange {
    + <<override>> StoreName : string <<get>>
    + <<override>> Initialize(manager:StoreManager, itemList:List<StoreItem>) : void
    + RenderToUI(slots:List<SlotUI>, iconCoin:Sprite, iconToken:Sprite, iconKeyMap:Sprite) : void
    + <<override>> Purchase(item:StoreItem) : bool
}
StoreBase <|-- StoreExchange
StoreExchange --> "StoreType" StoreType

enum StoreCurrency {
    Coin,
    Token,
    KeyMap,
}
class StoreItem {
    + ID : string
    + DisplayName : string
    + Price : int = 1
    + RewardAmount : int = 1
    + UnlockedByDefault : bool = false
    + UseLevelScaling : bool = false
    + MaxLevel : int = 5
    + PriceMultiplier : float = 1.5f
}
ScriptableObject <|-- StoreItem
StoreItem --> "StoreType" StoreType
StoreItem --> "Icon" Sprite
StoreItem --> "SpendCurrency" StoreCurrency
StoreItem --> "RewardCurrency" StoreCurrency
StoreItem --> "mapType" MapType

class StoreMap {
    + <<override>> StoreName : string <<get>>
    + <<override>> Initialize(manager:StoreManager, itemList:List<StoreItem>) : void
    + RenderToUI(slots:List<SlotUI>) : void
    + <<override>> Purchase(item:StoreItem) : bool
    + GetSceneName(item:StoreItem) : string
    + ForceUnlock(type:MapType) : void
    + <<override>> IsUnlocked(item:StoreItem) : bool
}
class "Action`1"<T> {
}
StoreBase <|-- StoreMap
StoreMap --> "StoreType" StoreType
StoreMap --> "OnMapUnlockedEvent<string>" "Action`1"

enum MapType {
    None= 0,
    School= 1,
    RoadTraffic= 2,
    Kitchen= 3,
    All= 99,
}
class MapTypeExtensions <<static>> {
    + {static} IsPlayableMap(mapType:MapType) : bool
    + {static} ToSceneName(mapType:MapType) : string
    + {static} FromSceneName(sceneName:string) : MapType
    + {static} IsUniversal(mapType:MapType) : bool
    + {static} ToFriendlyString(mapType:MapType) : string
    + {static} DebugInfo(mapType:MapType) : string
}

class StoreUpgrade {
    + <<override>> StoreName : string <<get>>
    + <<override>> Initialize(manager:StoreManager, injectedItems:List<StoreItem>) : void
    + RenderToUI(slots:List<SlotUI>) : void
    + <<override>> Purchase(item:StoreItem) : bool
    + <<override>> IsUnlocked(item:StoreItem) : bool
    + GetLevel(item:StoreItem) : int
    + SetLevel(item:StoreItem, newLevel:int) : void
    + GetPrice(item:StoreItem) : int
    + GetTotalHPBonus() : int
    + SyncWithSave() : void
}
StoreBase <|-- StoreUpgrade
StoreUpgrade --> "StoreType" StoreType

enum StoreType {
    None,
    Exchange,
    Upgrade,
    Map,
}

class StoreManager {
    + StoreManager(currency:Currency, progressData:GameProgressData)
    + RegisterStore(store:StoreBase) : void
    + Purchase(itemID:string) : bool
}
class "List`1"<T> {
}
StoreManager o-> "Stores<StoreBase>" "List`1"
StoreManager --> "Currency" Currency
StoreManager --> "ProgressData" GameProgressData

abstract class MapGeneratorBase {
    + WallPushSpeed : float <<get>> <<set>>
    + IsPlatformBreakable : bool <<get>> <<set>>
    + IsWallPushEnabled : bool <<get>> <<set>>
    + <<virtual>> InitializeGenerators(pivot:Transform) : void
    + {abstract} GenerateMap() : void
    + <<virtual>> SetupBackground() : void
    + <<virtual>> SetupFloor() : void
    + <<virtual>> SpawnEnemies() : void
    + <<virtual>> SpawnCollectibles() : void
    + <<virtual>> SpawnAssets() : void
    + <<virtual>> SpawnThrowables() : void
    + <<virtual>> BreakRightmostPlatform() : void
    + <<virtual>> WallUpdate() : void
    + SetWallPushSpeed(speed:float) : void
    + EnableWallPush(enabled:bool) : void
    + <<virtual>> ClearAllObjects() : void
}
enum PlatformState {
    Normal,
    AscendingSteps,
    DescendingSteps,
    HillUp,
    HillDown,
}
MonoBehaviour <|-- MapGeneratorBase
MapGeneratorBase +-- PlatformState

class MapGeneratorKitchen {
    + <<override>> GenerateMap() : void
    + <<override>> SetupBackground() : void
    + <<override>> SetupFloor() : void
}
MapGeneratorBase <|-- MapGeneratorKitchen

class MapGeneratorRoad {
    + <<override>> GenerateMap() : void
    + <<override>> SetupBackground() : void
}
MapGeneratorBase <|-- MapGeneratorRoad

class MapGeneratorSchool {
    + <<override>> GenerateMap() : void
    + <<override>> SetupBackground() : void
    + <<override>> SpawnEnemies() : void
    + <<override>> SpawnCollectibles() : void
    + <<override>> SpawnAssets() : void
    + <<override>> SpawnThrowables() : void
}
MapGeneratorBase <|-- MapGeneratorSchool

class SceneManager <<sealed>> {
    + {static}  <<event>> OnSceneInitialized : System.Action 
    + Inject(gen:MapGeneratorBase, player:Player) : void
    + TryInitializeScene() : void
    + GetCurrentSceneName() : string
    + GetCurrentMapType() : MapType
    + IsInitialized : bool <<get>>
    + GetMapGenerator() : MapGeneratorBase
    + ClearSceneObjects() : void
}
MonoBehaviour <|-- SceneManager

class SaveSystem {
    + Initialize() : void
    + GetProgressData() : GameProgressData
    + SaveData() : void
    + LoadData() : void
    + SetGlobalHighScore(newScore:int) : void
    + GetGlobalHighScore() : int
    + ResetData() : void
    + DeleteSave() : void
    + BackupSaveFile() : void
}
MonoBehaviour <|-- SaveSystem
SaveSystem --> "Instance" SaveSystem

class GameProgressData {
    + GlobalHighScore : int = 0
    + TotalCoins : int <<get>> <<set>>
    + TotalTokens : int <<get>> <<set>>
    + TotalKeyMaps : int <<get>> <<set>>
    + BestScore : int <<get>> <<set>>
    + PlayTime : float <<get>> <<set>>
    + GameProgressData()
    + GetUpgradeLevel(itemID:string) : int
    + SetUpgradeLevel(itemID:string, level:int) : void
    + AddUnlockedMap(id:string) : void
    + IsMapUnlocked(id:string) : bool
    + AddUnlockedCareer(id:string) : void
    + AddCoins(amount:int) : void
    + UpdateBestScore(score:int) : void
    + ResetProgress() : void
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
GameProgressData --> "UnlockedMaps<string>" "List`1"
GameProgressData --> "UnlockedCareers<string>" "List`1"
GameProgressData --> "UpgradeLevels<string,int>" "Dictionary`2"
GameProgressData --> "LastPlayDate" DateTime

class GameManager {
    + {static}  <<event>> OnCurrencyReady : System.Action 
    + IsPaused : bool <<get>>
    + Score : int <<get>>
    + PlayTime : float <<get>>
    + GetProgressData() : GameProgressData
    + GetCurrency() : Currency
    + GetStoreManager() : StoreManager
    + GetStoreList() : List<StoreBase>
    + {static}  <<event>> OnGameReady : Action 
    + LoadGameLevel(sceneName:string, mapType:MapType) : void
    + LoadScene(sceneName:string) : void
    + InitializeGame() : void
    + StartGame() : void
    + TogglePause() : void
    + PauseGame() : void
    + ResumeGame() : void
    + ResumeGameFromPauseButton() : void
    + RestartGameFromPause() : void
    + EndGame() : void
    + PlayerDieHandler() : void
    + ExitToMainMenuFromResults() : void
    + RestartGame() : void
    + ExitGame() : void
    + AddScore(amount:int) : void
    + GetPlayTime() : float
    + SaveProgress() : void
    + SetupStores(progressData:GameProgressData) : void
    + ResetGameProgress() : void
    + DeleteSaveAndRestart() : void
}
MonoBehaviour <|-- GameManager
GameManager --> "Instance" GameManager
GameManager --> "CardManager" CardManager
GameManager --> "CurrentMapType" MapType
GameManager --> "PlayerRef" Player

class UIManager {
    + GetScoreUI() : ScoreUI
    + SetDependencies(gm:GameManager, currency:Currency, storeManager:StoreManager, stores:List<StoreBase>) : void
    + ShowMainMenu() : void
    + ShowSelectMap() : void
    + ShowStoreMenu(isActive:bool) : void
    + SwitchStorePanel(type:StoreType) : void
    + ShowStoreBase() : void
    + ShowPrompt(message:string) : void
    + HidePrompt() : void
    + GetPlayerHealthBarUI() : HealthBarUI
    + InitializeHealth(maxHP:int) : void
    + UpdateHealth(currentHP:int) : void
    + ShowDamageEffect() : void
    + ShowHealEffect() : void
    + InitializeScore(startScore:int) : void
    + UpdateScore(newScore:int) : void
    + ShowComboEffect(combo:int) : void
    + DisplayHighScore(score:int) : void
    + UpdateCardSlots(cards:System.Collections.Generic.List<Card>) : void
    + HighlightCard(index:int) : void
    + ResetCardSlots() : void
    + ShowCardSelectionPanel(isActive:bool) : void
    + ShowPauseMenu(isActive:bool) : void
    + ShowResultMenu() : void
    + CloseAllMenus() : void
    + IsAnyMenuOpen() : bool
    + ShowGameplayHUD() : void
    + OpenStore() : void
    + ShowStoreExchange() : void
    + ShowStoreUpgrade() : void
    + ShowStoreMap() : void
    + RefreshStoreUI() : void
}
MonoBehaviour <|-- UIManager
UIManager --> "panelHUDMain" GameObject
UIManager --> "panelMainMenu" GameObject
UIManager --> "panelSelectMap" GameObject
UIManager --> "panelStore" GameObject
UIManager --> "panelSettings" GameObject
UIManager --> "panelStoreExchange" GameObject
UIManager --> "panelStoreUpgrade" GameObject
UIManager --> "upgradeUI" UpgradeUI
UIManager --> "Instance" UIManager

class ObjectPoolManager {
    + IsInitialized : bool <<get>> = false
    + <<virtual>> InitializePool() : void
    + <<virtual>> SpawnFromPool(objectTag:string, position:Vector3, rotation:Quaternion) : GameObject
    + <<virtual>> ReturnToPool(objectTag:string, obj:GameObject) : void
    + <<virtual>> ClearPool() : void
    + <<virtual>> ExpandPool(objectTag:string, additionalCount:int) : void
    + GetAllTags() : List<string>
}
MonoBehaviour <|-- ObjectPoolManager
IObjectPool <|-- ObjectPoolManager
ObjectPoolManager --> "Instance" ObjectPoolManager

class SceneManager <<sealed>> {
    + {static}  <<event>> OnSceneInitialized : System.Action 
    + Inject(gen:MapGeneratorBase, player:Player) : void
    + TryInitializeScene() : void
    + GetCurrentSceneName() : string
    + GetCurrentMapType() : MapType
    + IsInitialized : bool <<get>>
    + GetMapGenerator() : MapGeneratorBase
    + ClearSceneObjects() : void
}
MonoBehaviour <|-- SceneManager

class EnemySpawner {
    +  <<event>> OnEnemySpawned : System.Action<Enemy> 
    + InitializeSpawner(pool:IObjectPool, mapType:MapType, player:Player, collectibleSpawner:CollectibleSpawner, cardManager:CardManager, buffManager:BuffManager) : void
    + Spawn() : void
    + SpawnAtPosition(position:Vector3) : GameObject
    + Despawn(enemy:GameObject) : void
    + GetSpawnCount() : int
    + SpawnSpecificEnemy(type:EnemyType, position:Vector3) : GameObject
    + StartWave() : IEnumerator
}
MonoBehaviour <|-- EnemySpawner
ISpawn <|-- EnemySpawner


class AssetSpawner {
    + Initialize(pivot:Transform, pool:IObjectPool) : void
    + SpawnAtPosition(position:Vector3) : GameObject
    + Despawn(obj:GameObject) : void
    + GetSpawnCount() : int
    + Spawn() : void
}
MonoBehaviour <|-- AssetSpawner
ISpawn <|-- AssetSpawner

class ThrowableSpawner {
    + CanInteract : bool <<get>>
    + Initialize(pivot:Transform, enemySpawner:EnemySpawner) : void
    + Interact(player:Player) : void
    + ShowPrompt() : void
    + Spawn() : void
    + SpawnAtPosition(position:Vector3) : GameObject
    + Despawn(obj:GameObject) : void
    + GetSpawnCount() : int
}
MonoBehaviour <|-- ThrowableSpawner
ISpawn <|-- ThrowableSpawner
IInteractable <|-- ThrowableSpawner

class CollectibleSpawner {
    + InitializeSpawner(pool:IObjectPool, cullingManager:DistanceCulling, cardManager:CardManager, buffManager:BuffManager) : void
    + SetPlayer(player:Transform) : void
    + SpawnAtPosition(targetPos:Vector3) : GameObject
    + Spawn() : void
    + Despawn(collectible:GameObject) : void
    + GetSpawnCount() : int
    + DropCollectible(type:CollectibleType, position:Vector3) : GameObject
}
MonoBehaviour <|-- CollectibleSpawner
ISpawn <|-- CollectibleSpawner

class CollectibleSpawner {
    + InitializeSpawner(pool:IObjectPool, cullingManager:DistanceCulling, cardManager:CardManager, buffManager:BuffManager) : void
    + SetPlayer(player:Transform) : void
    + SpawnAtPosition(targetPos:Vector3) : GameObject
    + Spawn() : void
    + Despawn(collectible:GameObject) : void
    + GetSpawnCount() : int
    + DropCollectible(type:CollectibleType, position:Vector3) : GameObject
}
MonoBehaviour <|-- CollectibleSpawner
ISpawn <|-- CollectibleSpawner

class ComicEffectSpawner <<static>> {
    + {static} Spawn(data:ComicEffectData, target:Transform) : void
    + {static} Spawn(data:ComicEffectData, worldPos:Vector3) : void}

class CardManager {
    + IsReady : bool <<get>>
    + Initialize(player:Player) : void
    + SetCareerSwitcher(switcher:CareerSwitcher) : void
    + AddCard(newCard:Card) : void
    + RemoveCard(index:int) : void
    + OnClickStarterButton() : void
    + UseCard(index:int) : void
    + ActivateMuscleDuck() : void
    + AddStarterCard() : void
    + AddCareerCard() : void
}
MonoBehaviour <|-- CardManager
CardManager --> "Instance" CardManager
CardManager --> "starterPanel" RandomStarterCard


class ComicEffectManager {
    + Register(key:string, prefab:ComicEffectPlayer, preloadCount:int) : void
    + Play(data:ComicEffectData, pos:Vector3) : void
    + Release(fx:ComicEffectPlayer) : void
    + Initialize(player:Player) : void
}
MonoBehaviour <|-- ComicEffectManager
ComicEffectManager --> "Instance" ComicEffectManager


@enduml